<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习_facebook签到预测</title>
      <link href="/2022/10/06/facebook_%E7%AD%BE%E5%88%B0%E5%9C%B0%E7%82%B9%E9%A2%84%E6%B5%8B/"/>
      <url>/2022/10/06/facebook_%E7%AD%BE%E5%88%B0%E5%9C%B0%E7%82%B9%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Facebook签到地点预测案例"><a href="#Facebook签到地点预测案例" class="headerlink" title="Facebook签到地点预测案例"></a>Facebook签到地点预测案例</h1><p>由于此次处理的数据比较多，就把环境换成了jupyter，每行执行完都能看到结果</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./FBlocation/train.csv&quot;</span>) <span class="comment">#相对路径获取数据</span></span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>由于此文件数据量过于庞大，需要适当处理数据</p><p>先查看得到的数据</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_original_data.png"></p><ol><li>试着缩小数据范围</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = data.query(<span class="string">&quot;x &lt; 10 &amp; x &gt; 2 &amp; y &lt; 10 &amp; y &gt; 1.0&quot;</span>) <span class="comment"># 将x和y固定在一定范围内，虽然这里的范围是随便设的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>处理时间特征</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_value = pd.to_datetime(data[<span class="string">&quot;time&quot;</span>],unit=<span class="string">&quot;s&quot;</span>) </span><br></pre></td></tr></table></figure><p>此时time_value是</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_time_value.png"></p><p>再用date接收pd.DatetimeIndex(time_value)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date = pd.DatetimeIndex(time_value) <span class="comment"># 将时间按年月日时分妙按序列形式存起来</span></span><br></pre></td></tr></table></figure><p>则可以直接通过date[“hour”]访问其内容</p><p>观察发现，年份都是1970，月份都是1月，属于无效数据，此处取得日期，星期，和小时作为判断数据加入原data</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;day&quot;</span>] = date.day</span><br><span class="line">data[<span class="string">&quot;weekday&quot;</span>] = date.weekday</span><br><span class="line">data[<span class="string">&quot;hour&quot;</span>] = date.hour</span><br></pre></td></tr></table></figure><p>则得到了筛选后的data</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_after_data.png"></p><ol start="3"><li>过滤掉签到地点较少的地点，即不需要他们的place_id</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">place_count = data.groupby(<span class="string">&quot;place_id&quot;</span>).count()[<span class="string">&quot;row_id&quot;</span>] </span><br><span class="line"><span class="comment"># 统计每个place_id出现的次数，再取他们的行序号放到place_count</span></span><br><span class="line">data_final = data[data[<span class="string">&quot;place_id&quot;</span>].isin(place_count[place_count &gt; <span class="number">3</span>].index.values)]</span><br><span class="line"><span class="comment"># place_count[place_count &gt; 3]将place_id出现次数大于3的place_id纳入测试范围，将范围内的data数据放入data_final</span></span><br></pre></td></tr></table></figure><p>place_count[place_count &gt; 3]如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_place_count-3.png"></p><p>data_final如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb.data_final.png"></p><h1 id="筛选特征值和目标值"><a href="#筛选特征值和目标值" class="headerlink" title="筛选特征值和目标值"></a>筛选特征值和目标值</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = data_final[[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;weekday&quot;</span>, <span class="string">&quot;hour&quot;</span>]]</span><br><span class="line">y = data_final[<span class="string">&quot;place_id&quot;</span>]</span><br><span class="line"><span class="comment"># 确定x和y的内容</span></span><br></pre></td></tr></table></figure><p>x为被认为有影响的几个因素，y为我们最后要求得结果</p><p>然后就和上文提到的类似</p><h1 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test) </span><br><span class="line"><span class="comment"># 此处不能用fit_transform，x_test要和train做一样的操作，要用train的平均值，所以只transform就行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4） KNN算法预估器</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line"><span class="comment"># 参数准备</span></span><br><span class="line">param_dict = &#123;<span class="string">&quot;n_neighbors&quot;</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5） 模型评估</span></span><br><span class="line"><span class="comment"># 法1: 直接比对真实值和预测值</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>,y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>,y_test==y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2: 计算准确率</span></span><br><span class="line">score = estimator.score(x_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>,score)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:\n&quot;</span>, estimator.best_params_)</span><br><span class="line"><span class="comment"># 最佳结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳结果:\n&quot;</span>, estimator.best_score_)</span><br><span class="line"><span class="comment"># 最佳估计器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line"><span class="comment"># 交叉验证结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_result.png"></p><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>最后得出的准确率只有36%，可能由于x，y范围的选择和特征影响的判定没那么准确，这些地方应该可以优化，便不再提及，整个预测的大致流程就是如上。</p>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_KNN算法</title>
      <link href="/2022/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习-KNN算法"><a href="#机器学习-KNN算法" class="headerlink" title="机器学习_KNN算法"></a>机器学习_KNN算法</h1><h2 id="1、K-近邻算法"><a href="#1、K-近邻算法" class="headerlink" title="1、K-近邻算法"></a>1、K-近邻算法</h2><h3 id="1-1-定义-如果一个样本在特征空间中的k个最相似-即特征空间中最邻近-的样本中的大多数属于某一个类别，则该样本也属于这个类别。"><a href="#1-1-定义-如果一个样本在特征空间中的k个最相似-即特征空间中最邻近-的样本中的大多数属于某一个类别，则该样本也属于这个类别。" class="headerlink" title="1.1 定义:如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。"></a>1.1 定义:如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</h3><h3 id="1-2-距离公式-两个样本的差距也叫距离可以通过如下公式计算（欧式公式）"><a href="#1-2-距离公式-两个样本的差距也叫距离可以通过如下公式计算（欧式公式）" class="headerlink" title="1.2 距离公式:两个样本的差距也叫距离可以通过如下公式计算（欧式公式）:"></a>1.2 距离公式:两个样本的差距也叫距离可以通过如下公式计算（欧式公式）:</h3><p>比如A(a1,b1,c1) B(a2,b2.c2)<br>$$<br>\sqrt[]{(a1-a2)^2+(b1-b2)^2+(c1-c2^2)}<br>$$</p><h3 id="也有很多其他公式可代表距离，不唯一"><a href="#也有很多其他公式可代表距离，不唯一" class="headerlink" title="也有很多其他公式可代表距离，不唯一"></a>也有很多其他公式可代表距离，不唯一</h3><h3 id="1-3-K-近邻算法API"><a href="#1-3-K-近邻算法API" class="headerlink" title="1.3 K-近邻算法API"></a>1.3 K-近邻算法API</h3><ul><li>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)<ul><li>n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)</li></ul></li></ul><h1 id="基于鸢尾花数据集的测试"><a href="#基于鸢尾花数据集的测试" class="headerlink" title="基于鸢尾花数据集的测试"></a>基于鸢尾花数据集的测试</h1><ol><li><p>获取数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br></pre></td></tr></table></figure></li><li><p>划分数据集</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target,test_size=<span class="number">0.3</span>, random_state=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>将鸢尾花数据分为训练数据和测试数据，测试数据用于之后的准确性判断</p></li><li><p>特征工程：标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test) <span class="comment"># 此处不能用fit_transform，x_test要和train做一样的操作，要用train的平均值，所以只transform就行</span></span><br></pre></td></tr></table></figure></li><li><p>KNN算法预估器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x_train,y_train)</span><br></pre></td></tr></table></figure><p>将K值设为3，即当前样本在特征空间中的3个最相似(特征空间中距离最近)的样本大多都属于同一类别，则该样本也属于同一类别</p></li><li><p>模型评估</p><ol><li><p>直接对比真实值和预测值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y.predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>,y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>,y_test==y_predict) </span><br></pre></td></tr></table></figure></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%B8%A2%E5%B0%BE%E8%8A%B1_%E7%BB%93%E6%9E%9C.png"></p><ol start="2"><li><p>计算准确率</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = estimator.score(x_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>,score)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/机器学习_鸢尾花_准确率.png" style="zoom:200%;" /><ol start="3"><li>当test_size的值变化时，准确率也会变化。k值变化，准确率也会随之变化，k=3时，准确率=93.3%，k=4时，准确率=91%，k=5时，为95.6%，但不是线性变化。</li></ol></li></ol><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><h2 id="k值大小对数据的影响"><a href="#k值大小对数据的影响" class="headerlink" title="k值大小对数据的影响:"></a>k值大小对数据的影响:</h2><p>k值取很小：容易受到异常点的影响</p><p>k值取很大：受到样本均衡的问题</p><p>性能问题:计算距离时，时间复杂度较高</p><h1 id="交叉验证，模型选择与调优"><a href="#交叉验证，模型选择与调优" class="headerlink" title="交叉验证，模型选择与调优"></a>交叉验证，模型选择与调优</h1><h2 id="什么是交叉验证-cross-validation"><a href="#什么是交叉验证-cross-validation" class="headerlink" title="什么是交叉验证(cross validation)"></a>什么是交叉验证(cross validation)</h2><p>交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成5份，其中一份作为验证集。然后经过5次(组)的测试，每次都更换不同的验证集。即得到5组模型的结果，取平均值作为最终结果。又称5折交叉验证。</p><h2 id="模型选择与调优"><a href="#模型选择与调优" class="headerlink" title="模型选择与调优"></a>模型选择与调优</h2><ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)<ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析：<ul><li>best<em>score</em>:在交叉验证中验证的最好结果_</li><li>best<em>estimator</em>：最好的参数模型</li><li>cv<em>results</em>:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">param_dict = &#123;<span class="string">&quot;n_neighbors&quot;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">10</span>) <span class="comment"># 数据过大时cv需减小</span></span><br><span class="line">estimator.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:\n&quot;</span>, estimator.best_params_)</span><br><span class="line"><span class="comment"># 最佳结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳结果:\n&quot;</span>, estimator.best_score_)</span><br><span class="line"><span class="comment"># 最佳估计器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line"><span class="comment"># 交叉验证结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/鸢尾花_模型选择调优.png" style="zoom:150%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>优点：</p><ul><li>简单，易于理解，易于实现，无需训练</li></ul></li><li><p>缺点：</p><ul><li>懒惰算法，对测试样本分类时的计算量大，内存开销大</li><li>必须指定K值，K值选择不当则分类精度不能保证</li></ul></li><li><p>使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试</p></li></ul><p>ps：本文部分内容摘自GitBook</p>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2022/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="建站目的"><a href="#建站目的" class="headerlink" title="建站目的"></a>建站目的</h1><p>本站建立于2022年10月3日，笔者希望通过编写此博客督促自己的学习，同时记录生活中的美好和感悟</p><h1 id="博客分类"><a href="#博客分类" class="headerlink" title="博客分类"></a>博客分类</h1><p>博客大致会以记录学习为主，记录生活和感悟为辅。嗯…应该没了🥰</p>]]></content>
      
      
      <categories>
          
          <category> 本站介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
