<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模拟链表</title>
      <link href="/2022/11/11/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/11/11/%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="模拟链表"><a href="#模拟链表" class="headerlink" title="模拟链表"></a>模拟链表</h1><p>很多时候在算法题中 new 新的节点会很慢导致超时，所以会用数组模拟链表。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在链表中，有头节点，存放value的成员，指向下一个节点的next指针</p><p>对应的，在数组模拟的链表中，会定义一个 head 表示头指针，e[i] 表示节点 i 存放的值，ne[i] 表示节点 i 的下一个节点的下标的值，因为无法new新的节点，所以还需要一个 idx 值表示当前已经用到了哪个点（该点还没被用），即 idx 表示即将用上的点。</p><p>比如 ：</p><blockquote><p> 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p><p>此时 head = 0，n[0] = 1,n[1] =2 ……ne[0] = 1,ne[1] = 2…. idx = 5</p></blockquote><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>如题：</p><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 k 个插入的数后面的数；</li><li>在第 k 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 MM 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p><p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 xx。</li><li><code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k 个插入的数后面插入一个数 xx（此操作中 k 均大于 0）。</li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>10<br>H 9<br>I 1 1<br>D 1<br>D 0<br>H 6<br>I 3 6<br>I 4 5<br>I 4 5<br>I 3 4<br>D 6</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>6 4 6 5</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head表示头节点的下标</span></span><br><span class="line"><span class="comment">// e[i]表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少，即下标</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点,即下一个会被用上的点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;  <span class="comment">// 一开始链表无节点 head 指向-1</span></span><br><span class="line">    idx = <span class="number">0</span>;    <span class="comment">// 下一个要用的下标是 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[idx] = head，head = idx，e[idx] = x，idx++; <span class="comment">// 类似链表操作，idx为要新加的节点下标，先将 head 指向的下表给新加的节点的next指针....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将x插k的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x,ne[idx] = ne[k],ne[k] = idx, idx++; <span class="comment">// 类似头插</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标是k的后面一个点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]]; <span class="comment">// 直接跳过下一个即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="built_in">remove_</span>(k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head;i!=<span class="number">-1</span>;i = ne[i]) cout&lt;&lt;e[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS与BFS</title>
      <link href="/2022/11/10/DFS%E4%B8%8EBFS/"/>
      <url>/2022/11/10/DFS%E4%B8%8EBFS/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>DFS和BFS俗称深搜和宽搜，即深度优先搜索和宽度优先搜索。顾名思义，比如对于一棵树而言，DFS会将一个分支走到底再回溯再选择<strong>别的没走过的</strong>分支，直到把所有情况走完；BFS是一层一层遍历，把当前层所有情况遍历完再进入下一层。</p><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th>优劣</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td>占用空间较小</td></tr><tr><td>BFS</td><td>queue</td><td>O(2^h)</td><td>具有最短路性质</td></tr></tbody></table><blockquote><p>表格中h表示树的深度</p></blockquote><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>如题：<strong>排列数字</strong></p><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。</p><p>现在，请你按照字典序将所有的排列方法输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数 n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>按字典序输出所有排列方案，每个方案占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤7</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>想象 n 个位置，每个位置都可以填入 1 ~ n 的数字，从第一个位置开始对于每一个位置，选择一个数填进去，这个数要保证之前没被填入过，并且从小到大找这个数，找到数后存入对应的结果数组中即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> path[N];  <span class="comment">// 存结果的数组</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 状态数组，用于判断数字是否被填入过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span>   <span class="comment">// u代表当前填入到第 u 个数字，表示位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)   <span class="comment">// 如果 u==n 则代表已经填入了所有数字 可以输出结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)  <span class="comment">// 从小到大遍历，如果 i 没被填入过则放入结果数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])  <span class="comment">// 当这个数没被用过</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i;  <span class="comment">// 则在第 u 个位置填入i</span></span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">// 标记为已使用</span></span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);     <span class="comment">// 进入下一个位置</span></span><br><span class="line">            path[u] = <span class="number">0</span>;   <span class="comment">//恢复现场</span></span><br><span class="line">            st[i] = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DFS一定要记得恢复现场</p></blockquote><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>如题：<strong>走迷宫</strong></p><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p>最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。</p><p>请问，该人从左上角移动至右下角 (n,m)(n,m) 处，至少需要移动多少次。</p><p>数据保证 (1,1) 处和 (n,m) 处的数字为 00，且一定至少存在一条通路。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从左上角移动至右下角的最少移动次数。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>5 5<br>0 1 0 0 0<br>0 1 0 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0</p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>8</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>直接从起点一层一层向外扩展，对于上下左右四个点，如果该点可以走并且之前没走过，则可以向该点扩展，距离数组中该点的距离 = 上一点距离数组中的值 + 1</p><p>最后返回终点在距离数组中的值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 宽搜可以搜到最短路</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125; ,dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;  <span class="comment">// 方向，用于向上下左右四个方向遍历</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);  <span class="comment">// 将距离数组先都初始化为 -1</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;              <span class="comment">// 起点的距离为 0</span></span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);          <span class="comment">// 下面基本都是板子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first+dx[i],y = t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;d[x][y]==<span class="number">-1</span>&amp;&amp;g[x][y] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second]+<span class="number">1</span>;   </span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;<span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BFS大概框架都差不多，先创个queue，把起始点入队，再把和他相关的点入队，一层层向外扩</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2022/11/02/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2022/11/02/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r]之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−109≤x≤109,<br>1≤n,m≤10^5,<br>−10^9≤l≤r≤10^9,<br>−10000≤c≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>注意到 x 的范围是10^9级别，所以肯定不能直接写一个数组 装所有数据。但是注意到 n 和 m 的范围只到10^5,对于n来说最多需要n次对数轴的增减，对于m来说要访问2m次数轴的数（一次m要读取一个范围[l, r]  l 和 r各一次）。所以就算每次增减不同的位置，每次访问不同的起点和终点，也只会用到 n+2m （n和m都小于10^5,所以一共也就小于30万）个数轴上的位置，所以我们可以将每一次访问到的数按升序映射到一个 0——30万的数组上，再用之前文章提到的前缀和通过O(1)得到区间之间值的和就over了。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;  <span class="comment">//要离散化的数</span></span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">// 求x对应离散化的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)     <span class="comment">// 二分法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= alls[mid]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);  <span class="comment">// 后续要用来添加到映射后的数轴上</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);     <span class="comment">// 将需要离散化的数读入alls，也就是要将x映射到新数轴上</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);  <span class="comment">// 后续对每一个询问都要打印出结果，也是最后要用</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l); <span class="comment">// 将需要离散化的数读入alls，将l映射到新数轴上</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r); <span class="comment">// 将需要离散化的数读入alls，将r映射到新数轴上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 对装入alls的数排序</span></span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">//unique(alls.begin(), alls.end())是将alls不同的数放在前面，将重复的数放在后面，</span></span><br><span class="line">              <span class="comment">//返回的是最后一个不同的数的下一个数的下标，也就是返回的是重复被移到后面的数的开头的下标，然后将相同的数都erase掉，就只剩不同的数升序排列了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : add) <span class="comment">// 类似 python for循环的用法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); <span class="comment">// 前面注释提过，现在将所有数通过find函数映射到a[]数组中</span></span><br><span class="line">        a[x] += item.second; <span class="comment">// 将对应位置要加的数加上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>]+a[i]; <span class="comment">// 前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first),r = <span class="built_in">find</span>(item.second); <span class="comment">// 读取每一次询问对应的 l 和 r</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>]&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lowbit</title>
      <link href="/2022/11/02/lowbit/"/>
      <url>/2022/11/02/lowbit/</url>
      
        <content type="html"><![CDATA[<h1 id="lowbit算法"><a href="#lowbit算法" class="headerlink" title="lowbit算法"></a>lowbit算法</h1><p>主要用于求二进制数相关问题</p><h2 id="如题："><a href="#如题：" class="headerlink" title="如题："></a>如题：</h2><p>给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 11 的个数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>第二行包含 n 个整数，表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，其中的第 ii 个数表示数列中的第 ii 个数的二进制表示中 11 的个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000,<br>0≤数列中元素的值≤10^9</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure><h2 id="求解："><a href="#求解：" class="headerlink" title="求解："></a>求解：</h2><p>lowbit函数很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他返回的是x从低位到高位第一个1和往低位的所有0。比如1001000返回的就是1000。原理是 x 取负之后在计算机里是各位取反加1，比如1001000取反也就是</p><p>0110111+1=0111000再和1001000取与运算，也就得到1000.</p><p>放到这题里面也就是每次得到一个带1的尾巴，再用原数减去这个尾巴，减了几次就有几个1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) </span><br><span class="line">&#123;</span><br><span class="line">    x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>或者简洁版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= i &amp; -i) s ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>危险人物人脸识别</title>
      <link href="/2022/10/30/%E5%8D%B1%E9%99%A9%E4%BA%BA%E7%89%A9%E8%AF%86%E5%88%AB/"/>
      <url>/2022/10/30/%E5%8D%B1%E9%99%A9%E4%BA%BA%E7%89%A9%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="危险人物人脸识别"><a href="#危险人物人脸识别" class="headerlink" title="危险人物人脸识别"></a>危险人物人脸识别</h1><blockquote><p>最终实现一个通过摄像头识别指定人物人脸并发出提醒的程序</p></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>需要用到第三方库cv2，cmake，numpy，dlib，face_recognition，依次pip install就行，smtplib 和 MIMEText 用于发邮件</p><h3 id="face-recognition简介"><a href="#face-recognition简介" class="headerlink" title="face_recognition简介"></a>face_recognition简介</h3><p><code>face_recognition</code>号称是世界上最简单的基于<code>python</code>的<a href="https://so.csdn.net/so/search?q=%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB&spm=1001.2101.3001.7020">人脸识别</a>库，是在深度学习框架<code>dlib</code>上做的整合，<code>dlib</code>模型在LFW(Labeled Faces in the Wild)能有99.38的准确率。</p><h3 id="CV2简介"><a href="#CV2简介" class="headerlink" title="CV2简介"></a>CV2简介</h3><p>CV2指的是OpenCV2（Open Source Computer Vision Library），是一个开源的库平台<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89&spm=1001.2101.3001.7020">计算机视觉</a>库。有很强大的图片处理功能，可实现图像处理和计算机视觉方面的很多通用算法。</p><p><strong>特别提示</strong>：安装的时候用 opencv_python，但在导入使用的时候使用 cv2。</p><blockquote><p>ps：在安装dlib时可能会出现问题，我当时查的是因为python版本太高，还没有适配，降了版本之后再下，如果还有问题就去下对应python版本的whl文件，比如我的是3.8的版本，就下了“dlib-19.19.0-cp38-cp38-win_amd64.whl”这个文件。</p></blockquote><p>准备工作做完后开始正式实现</p><h3 id="导入人脸"><a href="#导入人脸" class="headerlink" title="导入人脸"></a>导入人脸</h3><p>我从网上下载了Elon Musk和Bill Gates的人脸，放在相同目录的face_img下。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imgElon = face_recognition.load_image_file(<span class="string">&#x27;face_img/ELonMusk.png&#x27;</span>)  <span class="comment"># 从目录下读取图片</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;ElonMusk&#x27;</span>, imgElon)  <span class="comment"># 显示读取的图片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/grey_musk.png"></p><p>单运行这一行会出现一个灰色的人脸，因为 face_recognition.load_image_file() 的输出图像是 rgb 格式，但是opencv中是 bgr 格式，所以要看到正常的样子，还需要转换一下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imgElon = face_recognition.load_image_file(<span class="string">&#x27;face_img/ELonMusk.png&#x27;</span>)  <span class="comment"># 从目录下读取图片</span></span><br><span class="line">imgElon = cv2.cvtColor(imgElon, cv2.COLOR_BGR2RGB)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;ElonMusk&#x27;</span>, imgElon)  <span class="comment"># 显示读取的图片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这样就可以得到一个正常的图片了。</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/real_musk.png"></p><h3 id="定位人脸"><a href="#定位人脸" class="headerlink" title="定位人脸"></a>定位人脸</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">face_recognition.face_locations() </span><br><span class="line"><span class="comment"># 以列表的形式返回图片中所有人脸的位置信息，列表中每一行是一个人脸的位置信息，包括[top, right, bottom, left]，分别代表框住人脸的矩形中左上角和右下角的坐标</span></span><br></pre></td></tr></table></figure><p>因为我们此时图片中只有一个人脸，所以只用取第0行的四个坐标就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faceLoc = face_recognition.face_locations(imgElon)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="face-encodings-获取图像文件中所有面部编码"><a href="#face-encodings-获取图像文件中所有面部编码" class="headerlink" title="face_encodings 获取图像文件中所有面部编码"></a>face_encodings 获取图像文件中所有面部编码</h3><p>face_recognition.face_encodings(image)方法可获取每个图像文件中每个面部的面部编码,参数仍是加载的图像image，由于每个图像中可能有多个脸，所以返回的是一个编码列表，后续访问时注意加上索引号或者依次遍历。每张人脸是一个128维的向量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeElon = face_recognition.face_encodings(imgElon)[<span class="number">0</span>] <span class="comment"># 仍然是列表取第一行</span></span><br></pre></td></tr></table></figure><h3 id="矩形框住面部"><a href="#矩形框住面部" class="headerlink" title="矩形框住面部"></a>矩形框住面部</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(imgElon, (faceLoc[<span class="number">3</span>], faceLoc[<span class="number">0</span>]), (faceLoc[<span class="number">1</span>], faceLoc[<span class="number">2</span>]), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>由于faceLoc接受到的是[top, right, bottom, left]，我的理解是面部的上 右 下 左 分别是两个横坐标两个纵坐标，cv2.rectangle()里需要矩形左上角和右下角的坐标，所以就是（左，上）（右，下）也就是对应的（3，0）（1，2）</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/rectangle_Musk.png"></p><h3 id="测试是否能判断人脸"><a href="#测试是否能判断人脸" class="headerlink" title="测试是否能判断人脸"></a>测试是否能判断人脸</h3><p>在拿到了人脸的编码后，就可以进行比对判断了，此时再导入一张测试人脸，load一个另一张Musk的照片进行比对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imgTest = face_recognition.load_image_file(<span class="string">&#x27;face_img/ElonMusk_test.png&#x27;</span>)</span><br><span class="line">imgTest = cv2.cvtColor(imgTest, cv2.COLOR_BGR2RGB)</span><br><span class="line">faceLocTest = face_recognition.face_locations(imgTest)[<span class="number">0</span>]</span><br><span class="line">encodeTest = face_recognition.face_encodings(imgTest)[<span class="number">0</span>]</span><br><span class="line">cv2.rectangle(imgTest, (faceLocTest[<span class="number">3</span>], faceLocTest[<span class="number">0</span>]), (faceLocTest[<span class="number">1</span>], faceLocTest[<span class="number">2</span>]), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 上述操作同第一个人脸的操作，导入，转RGB，找人脸位置，编码，框出来</span></span><br></pre></td></tr></table></figure><p>再用face_recognition.compare_faces() 函数通过他们的编码进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results = face_recognition.compare_faces([encodeElon], encodeTest) <span class="comment"># 返回bool值判断是否属于同一个人的人脸</span></span><br><span class="line">faceDis = face_recognition.face_distance([encodeElon], encodeTest) <span class="comment"># 返回测试人脸和导入人脸的距离，即相差值，差值越小越是一张人脸</span></span><br></pre></td></tr></table></figure><p>第一个参数装的是列表，里面可以存入多张照片的编码（此处只存了一张），分别于测试编码进行判断，上下两个函数的返回值也是列表，列表中分别装的是bool值和距离。</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/bool_and_dis.png"></p><blockquote><p>大致识别人脸的过程就做完了，然后准备开始实现视频中的人脸识别</p></blockquote><h1 id="Dangerous-character-identification-Project"><a href="#Dangerous-character-identification-Project" class="headerlink" title="Dangerous character identification Project"></a>Dangerous character identification Project</h1><h2 id="读取库中的人脸图片"><a href="#读取库中的人脸图片" class="headerlink" title="读取库中的人脸图片"></a>读取库中的人脸图片</h2><p>首先建一个文件夹，里面放要识别的人脸照片，我就命名为 ‘img_depository’ ，里面还是放了马斯克和比尔盖茨的照片，还有我的😎</p><p>大致思路就是从此文件夹中一个一个读取照片和照片的名字放到列表中（放在文件夹的图片命名最好就是人脸的名字）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;img_depository&#x27;</span>     <span class="comment"># 存放face的文件夹</span></span><br><span class="line">images = []</span><br><span class="line">classNames = []</span><br><span class="line">myList = os.listdir(path)  <span class="comment"># 将face_img中的图片名称导到myList表里面</span></span><br><span class="line"><span class="built_in">print</span>(myList)</span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> myList:</span><br><span class="line">    curImg = cv2.imread(<span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;cl&#125;</span>&#x27;</span>)    <span class="comment"># 将通过路径读取的图片放入列表</span></span><br><span class="line">    images.append(curImg)</span><br><span class="line">    classNames.append(os.path.splitext(cl)[<span class="number">0</span>])  <span class="comment"># 分离扩展名</span></span><br></pre></td></tr></table></figure><h2 id="获取每个人脸的编码"><a href="#获取每个人脸的编码" class="headerlink" title="获取每个人脸的编码"></a>获取每个人脸的编码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findEncodings</span>(<span class="params">images</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将images中的每一张img进行编码，再把每一个img对应的编码放到encodeList中</span></span><br><span class="line"><span class="string">    :param images:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    encodeList = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)    <span class="comment"># 图片命名必须都是英文，否则此处会报错</span></span><br><span class="line">        encode = face_recognition.face_encodings(img)[<span class="number">0</span>] </span><br><span class="line">        encodeList.append(encode)</span><br><span class="line">    <span class="keyword">return</span> encodeList</span><br><span class="line"></span><br><span class="line">encodeListKnow = findEncodings(images)  <span class="comment"># 得到img_depository中所有已知face的编码</span></span><br></pre></td></tr></table></figure><p>操作基本和demo一样，就是多了个列表，把所有的编码都放在列表里</p><h2 id="通过电脑摄像头读取当前需要判断的人脸信息"><a href="#通过电脑摄像头读取当前需要判断的人脸信息" class="headerlink" title="通过电脑摄像头读取当前需要判断的人脸信息"></a>通过电脑摄像头读取当前需要判断的人脸信息</h2><p>cap.read() 默认参数打开自带摄像头，返回两个值，第一个是bool值，表示是否成功读取，第二个是返回读取到的那一帧的图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">success, img = cap.read()  <span class="comment"># 第一个参数success 为True 或者False,代表有没有读取到图片.第二个参数img表示截取到一帧的图片</span></span><br><span class="line">imgS = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), <span class="literal">None</span>, <span class="number">0.25</span>, <span class="number">0.25</span>)  <span class="comment"># 缩1/4</span></span><br><span class="line">imgS = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)   <span class="comment"># 变为RGB</span></span><br><span class="line"></span><br><span class="line">facesCurFrame = face_recognition.face_locations(imgS)     <span class="comment"># 取到当前帧的面部位置信息，可能有多张人脸所以不加索引</span></span><br><span class="line">encodesCurFrame = face_recognition.face_encodings(imgS, facesCurFrame)  <span class="comment"># 对当前帧的面部信息编码，可能有多张人脸所以不加索引</span></span><br></pre></td></tr></table></figure><h2 id="和库中的人脸对比"><a href="#和库中的人脸对比" class="headerlink" title="和库中的人脸对比"></a>和库中的人脸对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> encodeFace, faceLoc <span class="keyword">in</span> <span class="built_in">zip</span>(encodesCurFrame, facesCurFrame):</span><br><span class="line">    matches = face_recognition.compare_faces(encodeListKnow, encodeFace)  <span class="comment"># 返回bool值，是否为库中出现的人</span></span><br><span class="line">    faceDis = face_recognition.face_distance(encodeListKnow, encodeFace)  <span class="comment"># 返回当前帧的面部和库中每一个面部信息的距离，距离越小越接近</span></span><br><span class="line">    <span class="built_in">print</span>(faceDis) <span class="comment"># 打印出和库中每个人脸的距离</span></span><br><span class="line">    matchIndex = np.argmin(faceDis)  <span class="comment"># 找到距离最小的那个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> matches[matchIndex]:  <span class="comment"># 如果距离最小的人脸并且判断为在库中出现过</span></span><br><span class="line">        name = classNames[matchIndex].upper() </span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        y1, x2, y2, x1 = faceLoc </span><br><span class="line">        cv2.rectangle(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.rectangle(img, (x1, y2-<span class="number">35</span>), (x2, y2),(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), cv2.FILLED)</span><br><span class="line">        cv2.putText(img, name, (x1+<span class="number">6</span>, y2-<span class="number">6</span>), cv2.FONT_HERSHEY_COMPLEX, <span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment"># 在画面上打出库中存下的名字</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="判断是否为危险人物"><a href="#判断是否为危险人物" class="headerlink" title="判断是否为危险人物"></a>判断是否为危险人物</h2><p>我这里写了一个函数，其实可以不用写，加了一个times主要是防止多次重复警告，警告一次就可以了，警告的地方也写了一个函数，是给我的邮箱发一个邮件，标题就是“危险人物某某某进入画面”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">name, times</span>):</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;SHC&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> times &lt; <span class="number">1</span>:</span><br><span class="line">            times = times + <span class="number">1</span></span><br><span class="line">            sendemail()</span><br><span class="line">    <span class="keyword">return</span> times</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sendemail</span>():</span><br><span class="line">    smtp_obj = smtplib.SMTP(<span class="string">&quot;smtp.qq.com&quot;</span>)</span><br><span class="line">    smtp_obj.login(<span class="string">&quot;1436686284@qq.com&quot;</span>, <span class="string">&quot;zgwdndcksnnthifj&quot;</span>)  <span class="comment"># 此处需要登录自己的邮箱在设置里面开通IMAP服务，复制授权码到这里的第二个参数</span></span><br><span class="line">    mail_text = <span class="string">f&quot;危险人物<span class="subst">&#123;name&#125;</span>出现在画面中&quot;</span></span><br><span class="line">    msg_body = MIMEText(mail_text, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    smtp_obj.sendmail(<span class="string">&quot;1436686284@qq.com&quot;</span>, [<span class="string">&quot;1436686284@qq.com&quot;</span>], msg_body.as_string())  <span class="comment"># 由第一个发给后面列表中的所有，我这里就是自己发自己</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件已发&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>judge()函数是接在 </p><p>cv2.putText(img, name, (x1+6, y2-6), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 2)  # 在画面上打出库中存下的名字 </p><p>这一行后面，因为确认了在库里才能继续判断是否是危险人物</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E9%82%AE%E4%BB%B6%E6%88%AA%E5%9B%BE.png"></p><p>我把自己设成了危险人物</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E8%AF%86%E5%88%AB%E5%88%B0SHC.png"></p><p>整体流程就是这样</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;img_depository&#x27;</span>     <span class="comment"># 存放face的文件夹</span></span><br><span class="line">images = []</span><br><span class="line">classNames = []</span><br><span class="line">myList = os.listdir(path)  <span class="comment"># 将face_img中的图片名称导到myList表里面</span></span><br><span class="line"><span class="built_in">print</span>(myList)</span><br><span class="line"><span class="keyword">for</span> cl <span class="keyword">in</span> myList:</span><br><span class="line">    curImg = cv2.imread(<span class="string">f&#x27;<span class="subst">&#123;path&#125;</span>/<span class="subst">&#123;cl&#125;</span>&#x27;</span>)</span><br><span class="line">    images.append(curImg)</span><br><span class="line">    classNames.append(os.path.splitext(cl)[<span class="number">0</span>])  <span class="comment"># 分离扩展名</span></span><br><span class="line"><span class="built_in">print</span>(classNames)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findEncodings</span>(<span class="params">images</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将images中的每一张img进行编码，再把每一个img对应的编码放到encodeList中</span></span><br><span class="line"><span class="string">    :param images:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    encodeList = []</span><br><span class="line">    <span class="keyword">for</span> img <span class="keyword">in</span> images:</span><br><span class="line">        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)    <span class="comment"># 图片命名必须都是英文，否则此处会报错</span></span><br><span class="line">        encode = face_recognition.face_encodings(img)[<span class="number">0</span>]</span><br><span class="line">        encodeList.append(encode)</span><br><span class="line">    <span class="keyword">return</span> encodeList</span><br><span class="line"></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendemail</span>():</span><br><span class="line">    smtp_obj = smtplib.SMTP(<span class="string">&quot;smtp.qq.com&quot;</span>)</span><br><span class="line">    smtp_obj.login(<span class="string">&quot;1436686284@qq.com&quot;</span>, <span class="string">&quot;zgwdndcksnnthifj&quot;</span>)</span><br><span class="line">    mail_text = <span class="string">f&quot;危险人物<span class="subst">&#123;name&#125;</span>出现在画面中&quot;</span></span><br><span class="line">    msg_body = MIMEText(mail_text, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    smtp_obj.sendmail(<span class="string">&quot;1436686284@qq.com&quot;</span>, [<span class="string">&quot;1436686284@qq.com&quot;</span>], msg_body.as_string())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;邮件已发&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encodeListKnow = findEncodings(images)  <span class="comment"># 得到img_depository中所有已知face的编码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encoding Complete&quot;</span>)</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)    <span class="comment"># 从网络摄像头读取画面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge</span>(<span class="params">name, times</span>):</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;SHC&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> times &lt; <span class="number">1</span>:</span><br><span class="line">            times = times + <span class="number">1</span></span><br><span class="line">            sendemail()</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    success, img = cap.read()  <span class="comment"># 第一个参数success 为True 或者False,代表有没有读取到图片.第二个参数img表示截取到一帧的图片</span></span><br><span class="line">    imgS = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), <span class="literal">None</span>, <span class="number">0.25</span>, <span class="number">0.25</span>)  <span class="comment"># 缩1/4</span></span><br><span class="line">    imgS = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)   <span class="comment"># 变为RGB</span></span><br><span class="line"></span><br><span class="line">    facesCurFrame = face_recognition.face_locations(imgS)     <span class="comment"># 取到当前帧的面部位置信息</span></span><br><span class="line">    encodesCurFrame = face_recognition.face_encodings(imgS, facesCurFrame)  <span class="comment"># 对当前帧的面部信息编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> encodeFace, faceLoc <span class="keyword">in</span> <span class="built_in">zip</span>(encodesCurFrame, facesCurFrame):</span><br><span class="line">        matches = face_recognition.compare_faces(encodeListKnow, encodeFace)  <span class="comment"># 返回bool值，是否为库中出现的人</span></span><br><span class="line">        faceDis = face_recognition.face_distance(encodeListKnow, encodeFace)  <span class="comment"># 返回当前帧的面部和库中每一个面部信息的距离，距离越小越接近</span></span><br><span class="line">        <span class="built_in">print</span>(faceDis)</span><br><span class="line">        matchIndex = np.argmin(faceDis)  <span class="comment"># 找到距离最小的那个</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> matches[matchIndex]:</span><br><span class="line">            name = classNames[matchIndex].upper()</span><br><span class="line">            <span class="built_in">print</span>(name)</span><br><span class="line">            y1, x2, y2, x1 = faceLoc</span><br><span class="line">            cv2.rectangle(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            cv2.rectangle(img, (x1, y2-<span class="number">35</span>), (x2, y2),(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), cv2.FILLED)</span><br><span class="line">            cv2.putText(img, name, (x1+<span class="number">6</span>, y2-<span class="number">6</span>), cv2.FONT_HERSHEY_COMPLEX, <span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">            times = judge(name, times)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y1, x2, y2, x1 = faceLoc</span><br><span class="line">            cv2.rectangle(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            cv2.rectangle(img, (x1, y2 - <span class="number">35</span>), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), cv2.FILLED)</span><br><span class="line">            cv2.putText(img, <span class="string">&#x27;未知&#x27;</span>, (x1 + <span class="number">6</span>, y2 - <span class="number">6</span>), cv2.FONT_HERSHEY_COMPLEX, <span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Webcam&#x27;</span>, img)</span><br><span class="line">    cv2.waitKey(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2022/10/28/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2022/10/28/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入一个长度为 n 的整数序列。</span><br><span class="line"></span><br><span class="line">接下来再输入 m 个询问，每个询问输入一对 l,r。</span><br><span class="line"></span><br><span class="line">对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</span><br></pre></td></tr></table></figure><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="第一想法："><a href="#第一想法：" class="headerlink" title="第一想法："></a>第一想法：</h2><p>对每一个询问分别求用一次从l到r的for循环相加，得到每一个对应询问的结果。</p><p>m个询问，每次询问n次加法，m*n次运算</p><h2 id="前缀和："><a href="#前缀和：" class="headerlink" title="前缀和："></a>前缀和：</h2><p>用一个数组s[]记录序列前n项的和，比如s[2]表示序列前两项的和，所以s[n] = s[n-1] + a[n]，那么从第 l 到第 r 个数的和就是s[r] - s[l-1]，一次询问中只用通过一次运算就可以得出结果</p><h4 id="得出前缀和数组-sum-："><a href="#得出前缀和数组-sum-：" class="headerlink" title="得出前缀和数组(sum[])："></a>得出前缀和数组(sum[])：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; a[i];   <span class="comment">// 得到序列</span></span><br><span class="line">       sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="处理每一个询问："><a href="#处理每一个询问：" class="headerlink" title="处理每一个询问："></a>处理每一个询问：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l&gt;&gt; r;</span><br><span class="line">        cout&lt;&lt;sum[r] - sum[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><p>输入一个长度为 n 的整数序列。</p><p>接下来输入 m 个操作，每个操作包含三个整数 l,r,c表示将序列中 [l,r]之间的每个数加上 c。</p><p>请你输出进行完所有操作后的序列。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数序列。</p><p>接下来 m 行，每行包含三个整数 l，r，c 表示一个操作。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 n 个整数，表示最终序列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤100000<br>1≤l≤r≤n<br>−1000≤c≤1000<br>−1000≤整数序列中元素的值≤1000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure><h4 id="第一想法：-1"><a href="#第一想法：-1" class="headerlink" title="第一想法："></a>第一想法：</h4><p>同上，对每一个询问的 l 到 r 做循环相加得到结果，但是时间复杂度太高，会卡案例。</p><h4 id="差分："><a href="#差分：" class="headerlink" title="差分："></a>差分：</h4><p>相当于前缀和的逆运算，构造一个数组b[], 让题目给出的序列a[n]为b[n]的前n项和，即a[n] = a[n-1] + b[n]。</p><h5 id="第一个问题：-如何实现l到r的变化"><a href="#第一个问题：-如何实现l到r的变化" class="headerlink" title="第一个问题： 如何实现l到r的变化"></a>第一个问题： 如何实现l到r的变化</h5><p>改变b[n]，则a[n]之后所有的数都会对应改变，在此题中则是将b[l] + c，则a[l] 之后所有的数都会加c ，再在b[r+1] - c,则实现了只在 l 到 r 间的变化。</p><h5 id="第二个问题：如何构造b-n-数组"><a href="#第二个问题：如何构造b-n-数组" class="headerlink" title="第二个问题：如何构造b[n]数组"></a>第二个问题：如何构造b[n]数组</h5><p>假设a[n]一开始全为0 ， 要得到前缀和为所给序列的数组b[n]， 相当于将每一个b[i]+a[i]（序列中第i个数） 再b[i+1] -a[i]（序列中第i个数）。即 l = r =i,相当于给一个全0的数组对于位置i插入题目给的数，i就是从1到n。</p><h4 id="给-l-到-r-加-c-的函数"><a href="#给-l-到-r-加-c-的函数" class="headerlink" title="给 l 到 r 加 c 的函数"></a>给 l 到 r 加 c 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造b-n-数组"><a href="#构造b-n-数组" class="headerlink" title="构造b[n]数组"></a>构造b[n]数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">insert</span>(i,i,a[i]);</span><br></pre></td></tr></table></figure><h4 id="对于每一个询问的操作"><a href="#对于每一个询问的操作" class="headerlink" title="对于每一个询问的操作"></a>对于每一个询问的操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="最后打印结果"><a href="#最后打印结果" class="headerlink" title="最后打印结果"></a>最后打印结果</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_决策树</title>
      <link href="/2022/10/09/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2022/10/09/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>通俗来讲就是通过一系列判定指标来将一个事物进行分类</p><p>比如，评奖学金的时候，会判断一个同学的绩点是不是靠前，参加的活动多不多，志愿时长长不长等等指标，最后判断出要不要给这位同学奖学金。显然各个评判标准的权重是不一样的，比如博主学校的绩点的占比达到了总的50%，也就是如果这位同学绩点很高，那么可以预测他极有可能拿到奖学金。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息----减少不确定性</span><br><span class="line">决策树应用了信息熵，信息增益，条件熵等概念，大概就是一种计算方式，可以用计算出一个特征他对分类结果的影响程度，也可以说减少了多少不确定性，减少的越多，这个特征则越有参考价值，具体计算方法便不再描述。</span><br></pre></td></tr></table></figure><h2 id="决策树的三种算法实现"><a href="#决策树的三种算法实现" class="headerlink" title="决策树的三种算法实现"></a>决策树的三种算法实现</h2><p>当然决策树的原理不止信息增益这一种，还有其他方法。但是原理都类似，就不去举例计算。</p><ul><li>ID3<ul><li>信息增益 最大的准则</li></ul></li><li>C4.5<ul><li>信息增益比 最大的准则</li></ul></li><li>CART<ul><li>分类树: 基尼系数 最小的准则 在sklearn中可以选择划分的默认原则</li><li>优势：划分更加细致</li></ul></li></ul><h2 id="决策树API"><a href="#决策树API" class="headerlink" title="决策树API"></a>决策树API</h2><ul><li>class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)<ul><li>决策树分类器</li><li>criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’</li><li>max_depth:树的深度大小</li><li>random_state:随机数种子</li></ul></li><li>其中会有些超参数：max_depth:树的深度大小</li></ul><h1 id="案例：泰坦尼克号乘客生存预测"><a href="#案例：泰坦尼克号乘客生存预测" class="headerlink" title="案例：泰坦尼克号乘客生存预测"></a>案例：泰坦尼克号乘客生存预测</h1><ul><li>泰坦尼克号数据</li></ul><p>在泰坦尼克号和titanic2数据帧描述泰坦尼克号上的个别乘客的生存状态。使用的数据集是由各种研究人员开始的。其中包括许多研究人员创建的旅客名单，由Michael A. Findlay编辑。我们提取的数据集中的特征是票的类别，存活，乘坐班，年龄，登陆，home.dest，房间，票，船和性别。</p><ol><li><p>乘坐仓位可以是社会阶层的代表，比如一穷二白的男主和出身富贵的女主</p></li><li><p>其中age部分数据存在缺失(用总的年龄平均值来填充)</p></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;D:/杂物/机器学习/机器学xiday2资料/02-代码/titanic.csv&quot;</span></span><br><span class="line">titanic = pd.read_csv(path)</span><br><span class="line">x = titanic[[<span class="string">&quot;pclass&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>]]</span><br><span class="line">y = titanic[<span class="string">&quot;survived&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.数据处理</span></span><br><span class="line"><span class="comment"># 1）缺失值处理</span></span><br><span class="line">x[<span class="string">&quot;age&quot;</span>].fillna(x[<span class="string">&quot;age&quot;</span>].mean(), inplace=<span class="literal">True</span>)  <span class="comment"># .mean()——填补平均值</span></span><br><span class="line">x = x.to_dict(orient=<span class="string">&quot;records&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3数据集划分</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">transfer = DictVectorizer()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line">estimator = DecisionTreeClassifier(criterion=<span class="string">&quot;entropy&quot;</span>,max_depth=<span class="number">10</span>)</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>, y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2: 计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>, score)</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/titanic_result_2.png"></p><h1 id="集成学习方法之随机森林"><a href="#集成学习方法之随机森林" class="headerlink" title="集成学习方法之随机森林"></a>集成学习方法之随机森林</h1><p><em>集成学习方法：</em> 集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是<strong>生成多个分类器/模型</strong>，各自独立地学习和作出预测。<strong>这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。</strong></p><p><em>随机森林：</em> 在机器学习中，<strong>随机森林是一个包含多个决策树的分类器</strong>，并且其输出的类别是由个别树输出的类别的众数而定。    </p><p>例如, 如果你训练了10个树, 其中有8个树的结果是True, 2个数的结果是False, 那么最终投票结果就是True</p><h2 id="随机森林原理过程"><a href="#随机森林原理过程" class="headerlink" title="随机森林原理过程"></a>随机森林原理过程</h2><p>学习算法根据下列算法而建造每棵树：</p><ul><li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul><li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li><li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li></ul></li><li>采取bootstrap抽样</li></ul><h3 id="为什么采用BootStrap抽样"><a href="#为什么采用BootStrap抽样" class="headerlink" title="为什么采用BootStrap抽样"></a>为什么采用BootStrap抽样</h3><ul><li>为什么要随机抽样训练集？　　<ul><li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li></ul></li><li>为什么要有放回地抽样？<ul><li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li></ul></li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)</p><ul><li>随机森林分类器</li><li>n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200</li><li>criteria：string，可选（default =“gini”）分割特征的测量方法</li><li>max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30</li><li>max_features=”auto”,每个决策树的最大特征数量<ul><li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li><li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li><li>If “log2”, then <code>max_features=log2(n_features)</code>.</li><li>If None, then <code>max_features=n_features</code>.</li></ul></li><li>bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样</li><li>min_samples_split:节点划分最少样本数</li><li>min_samples_leaf:叶子节点的最小样本数</li></ul></li><li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;D:/杂物/机器学习/机器学xiday2资料/02-代码/titanic.csv&quot;</span></span><br><span class="line">titanic = pd.read_csv(path)</span><br><span class="line">x = titanic[[<span class="string">&quot;pclass&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;sex&quot;</span>]]</span><br><span class="line">y = titanic[<span class="string">&quot;survived&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.数据处理</span></span><br><span class="line"><span class="comment"># 1）缺失值处理</span></span><br><span class="line">x[<span class="string">&quot;age&quot;</span>].fillna(x[<span class="string">&quot;age&quot;</span>].mean(), inplace=<span class="literal">True</span>)  <span class="comment"># .mean()——填补平均值</span></span><br><span class="line">x = x.to_dict(orient=<span class="string">&quot;records&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3数据集划分</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">transfer = DictVectorizer()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"></span><br><span class="line">estimator = RandomForestClassifier()</span><br><span class="line"><span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line"><span class="comment"># 参数准备</span></span><br><span class="line">param_dict = &#123;<span class="string">&quot;n_estimators&quot;</span>: [<span class="number">100</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">700</span>, <span class="number">900</span>, <span class="number">1100</span>],</span><br><span class="line">              <span class="string">&quot;max_depth&quot;</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5） 模型评估</span></span><br><span class="line"><span class="comment"># 法1: 直接比对真实值和预测值</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>, y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2: 计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:\n&quot;</span>, estimator.best_params_)</span><br><span class="line"><span class="comment"># 最佳结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳结果:\n&quot;</span>, estimator.best_score_)</span><br><span class="line"><span class="comment"># 最佳估计器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line"><span class="comment"># 交叉验证结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><p>部分结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/titanic_result.png"></p><h1 id="决策树和随机森林总结"><a href="#决策树和随机森林总结" class="headerlink" title="决策树和随机森林总结"></a>决策树和随机森林总结</h1><h2 id="决策树-1"><a href="#决策树-1" class="headerlink" title="决策树"></a>决策树</h2><ul><li>优点：<ul><li>简单的理解和解释，树木可视化。</li></ul></li><li>缺点：<ul><li><strong>决策树学习者可以创建不能很好地推广数据的过于复杂的树，这被称为过拟合。</strong></li></ul></li><li>改进：<ul><li>减枝cart算法(决策树API当中已经实现，随机森林参数调优有相关介绍)</li><li><strong>随机森林</strong></li></ul></li></ul><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><ul><li>在当前所有算法中，具有极好的准确率</li><li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li><li>能够评估各个特征在分类问题上的重要性</li><li>比单只决策树慢</li></ul>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_朴素贝叶斯算法</title>
      <link href="/2022/10/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95_%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B/"/>
      <url>/2022/10/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95_%E6%96%B0%E9%97%BB%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><h2 id="公式介绍："><a href="#公式介绍：" class="headerlink" title="公式介绍："></a>公式介绍：</h2><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.T-zCCgvCRkN13QhvCjZsfQHaCA?w=340&h=94&c=7&r=0&o=5&dpr=1.56&pid=1.7" style="zoom:150%;" /><p><strong>那么这个公式如果应用在文章分类的场景当中，我们可以这样看：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3.png"></p><p>公式分为三个部分：</p><ul><li>P(C)：每个文档类别的概率(某文档类别数／总文档数量)</li><li>P(W│C)：给定类别下特征（被预测文档中出现的词）的概率<ul><li>计算方法：P(F1│C)=Ni/N （训练文档中去计算）<ul><li>Ni为该F1词在C类别所有文档中出现的次数</li><li>N为所属类别C下的文档所有词出现的次数和</li></ul></li></ul></li><li>P(F1,F2,…) 预测文档中每个词的概率</li></ul><h2 id="文章分类计算——举例"><a href="#文章分类计算——举例" class="headerlink" title="文章分类计算——举例"></a>文章分类计算——举例</h2><ul><li>假设我们从<strong>训练数据集</strong>得到如下信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E8%B4%9D%E5%8F%B6%E6%96%AF_%E4%BE%8B%E5%AD%90.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">科技：P(科技|影院,支付宝,云计算) = 𝑃(影院,支付宝,云计算|科技)∗P(科技)=(<span class="number">8</span>/<span class="number">100</span>)∗(<span class="number">20</span>/<span class="number">100</span>)∗(<span class="number">63</span>/<span class="number">100</span>)∗(<span class="number">30</span>/<span class="number">90</span>) = <span class="number">0.00456109</span></span><br><span class="line"></span><br><span class="line">娱乐：P(娱乐|影院,支付宝,云计算) = 𝑃(影院,支付宝,云计算|娱乐)∗P(娱乐)=(<span class="number">56</span>/<span class="number">121</span>)∗(<span class="number">15</span>/<span class="number">121</span>)∗(<span class="number">0</span>/<span class="number">121</span>)∗(<span class="number">60</span>/<span class="number">90</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>显然，某个概率直接为0是不合理的</p><h1 id="拉普拉斯平滑系数"><a href="#拉普拉斯平滑系数" class="headerlink" title="拉普拉斯平滑系数"></a>拉普拉斯平滑系数</h1><p>目的：防止计算出的分类概率为0<br>$$<br>P(F _1∣C)= \frac{N+αm}{N_i+α}<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(娱乐|影院,支付宝,云计算) =P(影院,支付宝,云计算|娱乐)P(娱乐) =P(影院|娱乐)*P(支付宝|娱乐)*P(云计算|娱乐)P(娱乐)=(56+1/121+4)(15+1/121+4)(0+1/121+1*4)(60/90) = 0.00002</span><br></pre></td></tr></table></figure><h2 id="4、案例：20类新闻分类"><a href="#4、案例：20类新闻分类" class="headerlink" title="4、案例：20类新闻分类"></a>4、案例：20类新闻分类</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_20newsgroups</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">news = fetch_20newsgroups(subset=<span class="string">&quot;all&quot;</span>)</span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(news.data, news.target)</span><br><span class="line"><span class="comment"># 特征工程:文本特征抽取—tfidf  将句子分隔为一个个单词</span></span><br><span class="line">transfer = TfidfVectorizer()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test)</span><br><span class="line"><span class="comment"># 朴素贝叶斯算法预估器流程</span></span><br><span class="line">estimator = MultinomialNB()</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>, y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>, y_test == y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2: 计算准确率</span></span><br><span class="line">score = estimator.score(x_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>, score)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E8%B4%9D%E5%8F%B6%E6%96%AF_%E7%BB%93%E6%9E%9C.png"></p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><ul><li>优点：<ul><li>朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。</li><li>对缺失数据不太敏感，算法也比较简单，常用于文本分类。</li><li>分类准确度高，速度快</li></ul></li><li>缺点：<ul><li>由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好</li></ul></li></ul><p>ps：摘自Gitbook</p>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_facebook签到预测</title>
      <link href="/2022/10/06/facebook_%E7%AD%BE%E5%88%B0%E5%9C%B0%E7%82%B9%E9%A2%84%E6%B5%8B/"/>
      <url>/2022/10/06/facebook_%E7%AD%BE%E5%88%B0%E5%9C%B0%E7%82%B9%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Facebook签到地点预测案例"><a href="#Facebook签到地点预测案例" class="headerlink" title="Facebook签到地点预测案例"></a>Facebook签到地点预测案例</h1><p>由于此次处理的数据比较多，就把环境换成了jupyter，每行执行完都能看到结果</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./FBlocation/train.csv&quot;</span>) <span class="comment">#相对路径获取数据</span></span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>由于此文件数据量过于庞大，需要适当处理数据</p><p>先查看得到的数据</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_original_data.png"></p><ol><li>试着缩小数据范围</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = data.query(<span class="string">&quot;x &lt; 10 &amp; x &gt; 2 &amp; y &lt; 10 &amp; y &gt; 1.0&quot;</span>) <span class="comment"># 将x和y固定在一定范围内，虽然这里的范围是随便设的</span></span><br></pre></td></tr></table></figure><ol start="2"><li>处理时间特征</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_value = pd.to_datetime(data[<span class="string">&quot;time&quot;</span>],unit=<span class="string">&quot;s&quot;</span>) </span><br></pre></td></tr></table></figure><p>此时time_value是</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_time_value.png"></p><p>再用date接收pd.DatetimeIndex(time_value)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date = pd.DatetimeIndex(time_value) <span class="comment"># 将时间按年月日时分妙按序列形式存起来</span></span><br></pre></td></tr></table></figure><p>则可以直接通过date[“hour”]访问其内容</p><p>观察发现，年份都是1970，月份都是1月，属于无效数据，此处取得日期，星期，和小时作为判断数据加入原data</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">&quot;day&quot;</span>] = date.day</span><br><span class="line">data[<span class="string">&quot;weekday&quot;</span>] = date.weekday</span><br><span class="line">data[<span class="string">&quot;hour&quot;</span>] = date.hour</span><br></pre></td></tr></table></figure><p>则得到了筛选后的data</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_after_data.png"></p><ol start="3"><li>过滤掉签到地点较少的地点，即不需要他们的place_id</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">place_count = data.groupby(<span class="string">&quot;place_id&quot;</span>).count()[<span class="string">&quot;row_id&quot;</span>] </span><br><span class="line"><span class="comment"># 统计每个place_id出现的次数，再取他们的行序号放到place_count</span></span><br><span class="line">data_final = data[data[<span class="string">&quot;place_id&quot;</span>].isin(place_count[place_count &gt; <span class="number">3</span>].index.values)]</span><br><span class="line"><span class="comment"># place_count[place_count &gt; 3]将place_id出现次数大于3的place_id纳入测试范围，将范围内的data数据放入data_final</span></span><br></pre></td></tr></table></figure><p>place_count[place_count &gt; 3]如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_place_count-3.png"></p><p>data_final如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb.data_final.png"></p><h1 id="筛选特征值和目标值"><a href="#筛选特征值和目标值" class="headerlink" title="筛选特征值和目标值"></a>筛选特征值和目标值</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = data_final[[<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;day&quot;</span>, <span class="string">&quot;weekday&quot;</span>, <span class="string">&quot;hour&quot;</span>]]</span><br><span class="line">y = data_final[<span class="string">&quot;place_id&quot;</span>]</span><br><span class="line"><span class="comment"># 确定x和y的内容</span></span><br></pre></td></tr></table></figure><p>x为被认为有影响的几个因素，y为我们最后要求得结果</p><p>然后就和上文提到的类似</p><h1 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test) </span><br><span class="line"><span class="comment"># 此处不能用fit_transform，x_test要和train做一样的操作，要用train的平均值，所以只transform就行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4） KNN算法预估器</span></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入网格搜索与交叉验证</span></span><br><span class="line"><span class="comment"># 参数准备</span></span><br><span class="line">param_dict = &#123;<span class="string">&quot;n_neighbors&quot;</span>: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5） 模型评估</span></span><br><span class="line"><span class="comment"># 法1: 直接比对真实值和预测值</span></span><br><span class="line">y_predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>,y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>,y_test==y_predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2: 计算准确率</span></span><br><span class="line">score = estimator.score(x_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>,score)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:\n&quot;</span>, estimator.best_params_)</span><br><span class="line"><span class="comment"># 最佳结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳结果:\n&quot;</span>, estimator.best_score_)</span><br><span class="line"><span class="comment"># 最佳估计器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line"><span class="comment"># 交叉验证结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/fb_result.png"></p><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>最后得出的准确率只有36%，可能由于x，y范围的选择和特征影响的判定没那么准确，这些地方应该可以优化，便不再提及，整个预测的大致流程就是如上。</p>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_KNN算法</title>
      <link href="/2022/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习-KNN算法"><a href="#机器学习-KNN算法" class="headerlink" title="机器学习_KNN算法"></a>机器学习_KNN算法</h1><h2 id="1、K-近邻算法"><a href="#1、K-近邻算法" class="headerlink" title="1、K-近邻算法"></a>1、K-近邻算法</h2><h3 id="1-1-定义-如果一个样本在特征空间中的k个最相似-即特征空间中最邻近-的样本中的大多数属于某一个类别，则该样本也属于这个类别。"><a href="#1-1-定义-如果一个样本在特征空间中的k个最相似-即特征空间中最邻近-的样本中的大多数属于某一个类别，则该样本也属于这个类别。" class="headerlink" title="1.1 定义:如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。"></a>1.1 定义:如果一个样本在特征空间中的<strong>k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别</strong>，则该样本也属于这个类别。</h3><h3 id="1-2-距离公式-两个样本的差距也叫距离可以通过如下公式计算（欧式公式）"><a href="#1-2-距离公式-两个样本的差距也叫距离可以通过如下公式计算（欧式公式）" class="headerlink" title="1.2 距离公式:两个样本的差距也叫距离可以通过如下公式计算（欧式公式）:"></a>1.2 距离公式:两个样本的差距也叫距离可以通过如下公式计算（欧式公式）:</h3><p>比如A(a1,b1,c1) B(a2,b2.c2)<br>$$<br>\sqrt[]{(a1-a2)^2+(b1-b2)^2+(c1-c2^2)}<br>$$</p><h3 id="也有很多其他公式可代表距离，不唯一"><a href="#也有很多其他公式可代表距离，不唯一" class="headerlink" title="也有很多其他公式可代表距离，不唯一"></a>也有很多其他公式可代表距离，不唯一</h3><h3 id="1-3-K-近邻算法API"><a href="#1-3-K-近邻算法API" class="headerlink" title="1.3 K-近邻算法API"></a>1.3 K-近邻算法API</h3><ul><li>sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm=’auto’)<ul><li>n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数</li><li>algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)</li></ul></li></ul><h1 id="基于鸢尾花数据集的测试"><a href="#基于鸢尾花数据集的测试" class="headerlink" title="基于鸢尾花数据集的测试"></a>基于鸢尾花数据集的测试</h1><ol><li><p>获取数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iris = load_iris()</span><br></pre></td></tr></table></figure></li><li><p>划分数据集</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target,test_size=<span class="number">0.3</span>, random_state=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>将鸢尾花数据分为训练数据和测试数据，测试数据用于之后的准确性判断</p></li><li><p>特征工程：标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transfer = StandardScaler()</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.transform(x_test) <span class="comment"># 此处不能用fit_transform，x_test要和train做一样的操作，要用train的平均值，所以只transform就行</span></span><br></pre></td></tr></table></figure></li><li><p>KNN算法预估器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x_train,y_train)</span><br></pre></td></tr></table></figure><p>将K值设为3，即当前样本在特征空间中的3个最相似(特征空间中距离最近)的样本大多都属于同一类别，则该样本也属于同一类别</p></li><li><p>模型评估</p><ol><li><p>直接对比真实值和预测值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y.predict = estimator.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_predict: \n&quot;</span>,y_predict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;直接比对真实值和预测值: \n&quot;</span>,y_test==y_predict) </span><br></pre></td></tr></table></figure></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%B8%A2%E5%B0%BE%E8%8A%B1_%E7%BB%93%E6%9E%9C.png"></p><ol start="2"><li><p>计算准确率</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = estimator.score(x_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率为: \n&quot;</span>,score)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/机器学习_鸢尾花_准确率.png" style="zoom:200%;" /><ol start="3"><li>当test_size的值变化时，准确率也会变化。k值变化，准确率也会随之变化，k=3时，准确率=93.3%，k=4时，准确率=91%，k=5时，为95.6%，但不是线性变化。</li></ol></li></ol><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><h2 id="k值大小对数据的影响"><a href="#k值大小对数据的影响" class="headerlink" title="k值大小对数据的影响:"></a>k值大小对数据的影响:</h2><p>k值取很小：容易受到异常点的影响</p><p>k值取很大：受到样本均衡的问题</p><p>性能问题:计算距离时，时间复杂度较高</p><h1 id="交叉验证，模型选择与调优"><a href="#交叉验证，模型选择与调优" class="headerlink" title="交叉验证，模型选择与调优"></a>交叉验证，模型选择与调优</h1><h2 id="什么是交叉验证-cross-validation"><a href="#什么是交叉验证-cross-validation" class="headerlink" title="什么是交叉验证(cross validation)"></a>什么是交叉验证(cross validation)</h2><p>交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成5份，其中一份作为验证集。然后经过5次(组)的测试，每次都更换不同的验证集。即得到5组模型的结果，取平均值作为最终结果。又称5折交叉验证。</p><h2 id="模型选择与调优"><a href="#模型选择与调优" class="headerlink" title="模型选择与调优"></a>模型选择与调优</h2><ul><li>sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)<ul><li>对估计器的指定参数值进行详尽搜索</li><li>estimator：估计器对象</li><li>param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}</li><li>cv：指定几折交叉验证</li><li>fit：输入训练数据</li><li>score：准确率</li><li>结果分析：<ul><li>best<em>score</em>:在交叉验证中验证的最好结果_</li><li>best<em>estimator</em>：最好的参数模型</li><li>cv<em>results</em>:每次交叉验证后的验证集准确率结果和训练集准确率结果</li></ul></li></ul></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">param_dict = &#123;<span class="string">&quot;n_neighbors&quot;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_dict, cv=<span class="number">10</span>) <span class="comment"># 数据过大时cv需减小</span></span><br><span class="line">estimator.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:\n&quot;</span>, estimator.best_params_)</span><br><span class="line"><span class="comment"># 最佳结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳结果:\n&quot;</span>, estimator.best_score_)</span><br><span class="line"><span class="comment"># 最佳估计器</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳估计器:\n&quot;</span>, estimator.best_estimator_)</span><br><span class="line"><span class="comment"># 交叉验证结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交叉验证结果:\n&quot;</span>, estimator.cv_results_)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/bibabu01/blog_img/鸢尾花_模型选择调优.png" style="zoom:150%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>优点：</p><ul><li>简单，易于理解，易于实现，无需训练</li></ul></li><li><p>缺点：</p><ul><li>懒惰算法，对测试样本分类时的计算量大，内存开销大</li><li>必须指定K值，K值选择不当则分类精度不能保证</li></ul></li><li><p>使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试</p></li></ul><p>ps：本文部分内容摘自GitBook</p>]]></content>
      
      
      <categories>
          
          <category> -机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习_算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2022/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/10/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="建站目的"><a href="#建站目的" class="headerlink" title="建站目的"></a>建站目的</h1><p>本站建立于2022年10月3日，笔者希望通过编写此博客督促自己的学习，同时记录生活中的美好和感悟</p><h1 id="博客分类"><a href="#博客分类" class="headerlink" title="博客分类"></a>博客分类</h1><p>博客大致会以记录学习为主，记录生活和感悟为辅。嗯…应该没了🥰</p>]]></content>
      
      
      <categories>
          
          <category> 本站介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
